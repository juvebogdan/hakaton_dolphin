"""
visualize_misclassified_spectrograms.py

This script visualizes spectrograms of misclassified examples from the dolphin whistle classifier.
It reads the misclassified_examples.csv file generated by the classifier and creates spectrograms
for the misclassified audio files.
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import signal
import wave
from tqdm import tqdm
import argparse

class MisclassifiedSpectrogramVisualizer:
    """
    Visualizer for spectrograms of misclassified examples
    """
    def __init__(self, csv_file, audio_dir, output_dir=None):
        """
        Initialize the visualizer
        
        Args:
            csv_file: Path to the misclassified_examples.csv file
            audio_dir: Directory containing audio files
            output_dir: Directory to save spectrograms (default: same as csv_file)
        """
        self.csv_file = csv_file
        self.audio_dir = audio_dir
        self.output_dir = output_dir or os.path.join(os.path.dirname(csv_file), 'spectrograms')
        
        # Create output directory if it doesn't exist
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Load misclassified examples
        self.load_misclassified_examples()
    
    def load_misclassified_examples(self):
        """
        Load misclassified examples from CSV file
        """
        print(f"Loading misclassified examples from {self.csv_file}")
        self.misclassified_df = pd.read_csv(self.csv_file)
        
        # Extract indices and labels
        self.indices = self.misclassified_df['file_index'].values
        self.true_labels = self.misclassified_df['true_label'].values
        self.predicted_labels = self.misclassified_df['predicted_label'].values
        self.probabilities = self.misclassified_df['prediction_probability'].values
        
        # Debug prints
        print("\nDetailed Debug Information:")
        print(f"Total examples in CSV: {len(self.indices)}")
        print("\nRaw data sample:")
        print(self.misclassified_df.head())
        print("\nData types:")
        print(self.misclassified_df.dtypes)
        
        print("\nLabel distributions:")
        print("True labels:", self.true_labels[:10], "...")
        print("Predicted labels:", self.predicted_labels[:10], "...")
        print("\nLabel value counts:")
        print("True labels value counts:\n", pd.Series(self.true_labels).value_counts())
        print("Predicted labels value counts:\n", pd.Series(self.predicted_labels).value_counts())
        
        # Ensure labels are numeric
        self.true_labels = pd.to_numeric(self.true_labels, errors='coerce')
        self.predicted_labels = pd.to_numeric(self.predicted_labels, errors='coerce')
        
        # Count false positives and false negatives
        self.false_positives = np.sum((self.predicted_labels == 1) & (self.true_labels == 0))
        self.false_negatives = np.sum((self.predicted_labels == 0) & (self.true_labels == 1))
        
        print("\nMisclassification analysis:")
        print(f"False positives (noise classified as whistle): {self.false_positives}")
        print(f"False negatives (whistle classified as noise): {self.false_negatives}")
        print(f"Total misclassified: {self.false_positives + self.false_negatives}")
        
        # Detailed analysis of misclassifications
        fp_mask = (self.predicted_labels == 1) & (self.true_labels == 0)
        fn_mask = (self.predicted_labels == 0) & (self.true_labels == 1)
        
        print("\nFalse Positive Details:")
        if np.any(fp_mask):
            fp_examples = self.misclassified_df[fp_mask]
            print("Sample of false positives:")
            print(fp_examples.head())
        else:
            print("No false positives found")
            
        print("\nFalse Negative Details:")
        if np.any(fn_mask):
            fn_examples = self.misclassified_df[fn_mask]
            print("Sample of false negatives:")
            print(fn_examples.head())
        else:
            print("No false negatives found")
        
        # Verify the counts match
        fp_indices = np.where((self.predicted_labels == 1) & (self.true_labels == 0))[0]
        fn_indices = np.where((self.predicted_labels == 0) & (self.true_labels == 1))[0]
        print(f"\nDouble-check using indices:")
        print(f"False positive indices count: {len(fp_indices)}")
        print(f"False negative indices count: {len(fn_indices)}")
        print(f"Total misclassified (via indices): {len(fp_indices) + len(fn_indices)}")
        
        print(f"\nLoaded {len(self.indices)} misclassified examples")
        
        # Check if there are any columns that might contain filenames
        self.filename_columns = []
        for col in self.misclassified_df.columns:
            # Look for columns that might contain filenames (contain 'file', 'name', 'path', etc.)
            if any(keyword in col.lower() for keyword in ['file', 'name', 'path', 'wav', 'audio']):
                self.filename_columns.append(col)
            # Also check if column values look like filenames (contain .wav)
            elif len(self.misclassified_df) > 0 and isinstance(self.misclassified_df[col].iloc[0], str) and '.wav' in self.misclassified_df[col].iloc[0]:
                self.filename_columns.append(col)
        
        if self.filename_columns:
            print(f"Found potential filename columns: {self.filename_columns}")
    
    def read_wav(self, filepath):
        """
        Read WAV file and return signal
        
        Args:
            filepath: Path to WAV file
            
        Returns:
            tuple: (audio signal, sample rate)
        """
        try:
            with wave.open(filepath, 'rb') as wav:
                sample_rate = wav.getframerate()
                frames = wav.getnframes()
                audio_bytes = wav.readframes(frames)
                return np.frombuffer(audio_bytes, dtype=np.int16), sample_rate
        except Exception as e:
            print(f"Error reading WAV file {filepath}: {e}")
            return None, None
    
    def get_spectrogram(self, audio, sample_rate, params=None):
        """
        Compute spectrogram with parameters suited for dolphin whistles
        
        Args:
            audio: Audio signal array
            sample_rate: Sample rate of the audio
            params: Dictionary containing spectrogram parameters
                   Default: {'NFFT': 2048, 'Fs': sample_rate, 'noverlap': 1536}
            
        Returns:
            tuple: (spectrogram array, frequency bins, time bins)
        """
        if params is None:
            params = {
                'NFFT': 2048,
                'Fs': sample_rate,
                'noverlap': 1536
            }
            
        freqs, times, Sxx = signal.spectrogram(audio,
                                             fs=params['Fs'],
                                             nperseg=params['NFFT'],
                                             noverlap=params['noverlap'],
                                             scaling='density')
        
        Sxx = 10 * np.log10(Sxx + 1e-10)
        
        return Sxx, freqs, times
    
    def find_audio_file(self, idx, file_index, all_audio_files):
        """
        Find the audio file corresponding to the given index
        
        Args:
            idx: Index in the misclassified_df
            file_index: The index value from the CSV
            all_audio_files: List of (filepath, filename) tuples
            
        Returns:
            tuple: (filepath, filename) or (None, None) if not found
        """
        # First, check if we have filename columns in the CSV
        if hasattr(self, 'filename_columns') and self.filename_columns:
            for col in self.filename_columns:
                filename = self.misclassified_df.iloc[idx][col]
                if isinstance(filename, str):
                    # Try to find this filename in the audio files
                    for filepath, audio_filename in all_audio_files:
                        if filename in audio_filename or audio_filename in filename:
                            return filepath, audio_filename
        
        # If we couldn't find by filename columns, try by index
        # Try to find the audio file by index
        for filepath, filename in all_audio_files:
            # Try different ways to match the index
            if (str(int(file_index)) == filename.split('.')[0] or 
                f"_{int(file_index)}_" in filename or 
                f"_{int(file_index)}." in filename or
                f".{int(file_index)}." in filename or
                filename.startswith(f"{int(file_index)}_") or
                filename.startswith(f"{int(file_index)}.") or
                # Try with the original float value
                str(file_index) == filename.split('.')[0] or 
                f"_{file_index}_" in filename or 
                f"_{file_index}." in filename or
                f".{file_index}." in filename or
                filename.startswith(f"{file_index}_") or
                filename.startswith(f"{file_index}.")):
                return filepath, filename
        
        # If still not found, try a more flexible approach with the index as part of the filename
        index_str = str(int(file_index))
        for filepath, filename in all_audio_files:
            if index_str in filename:
                return filepath, filename
        
        # If we still can't find it, create a synthetic spectrogram
        return None, None
    
    def visualize_spectrograms(self, random_seed=42):
        """
        Visualize spectrograms of all misclassified examples
        
        Args:
            random_seed: Random seed for reproducibility
        """
        # Set random seed for reproducibility
        np.random.seed(random_seed)
        
        # Get indices of false positives and false negatives
        fp_indices = np.where((self.predicted_labels == 1) & (self.true_labels == 0))[0]
        fn_indices = np.where((self.predicted_labels == 0) & (self.true_labels == 1))[0]
        
        # Get list of all audio files
        all_audio_files = []
        for root, dirs, files in os.walk(self.audio_dir):
            for file in files:
                if file.endswith('.wav'):
                    all_audio_files.append((os.path.join(root, file), file))
        
        print(f"Found {len(all_audio_files)} audio files in {self.audio_dir}")
        
        # Print some example filenames to help with debugging
        print("Example audio filenames:")
        for i, (_, filename) in enumerate(all_audio_files[:5]):
            print(f"  {i+1}. {filename}")
        
        # Visualize all false positives (noise classified as whistle)
        print(f"Visualizing {len(fp_indices)} false positives...")
        for i, idx in enumerate(tqdm(fp_indices, desc="Processing false positives")):
            file_index = self.indices[idx]
            probability = self.probabilities[idx]
            
            # Try to find the audio file
            filepath, filename = self.find_audio_file(idx, file_index, all_audio_files)
            
            if filepath:
                # Read audio file
                audio, sample_rate = self.read_wav(filepath)
                
                if audio is not None and sample_rate is not None:
                    # Generate spectrogram
                    Sxx, freqs, times = self.get_spectrogram(audio, sample_rate)
                    
                    # Plot spectrogram
                    plt.figure(figsize=(12, 8))
                    plt.pcolormesh(times, freqs/1000, Sxx, shading='gouraud')
                    plt.colorbar(label='Power/Frequency (dB/Hz)')
                    plt.ylabel('Frequency (kHz)')
                    plt.xlabel('Time (s)')
                    plt.title(f'False Positive: {filename}\nNoise classified as Whistle (Prob: {probability:.3f})')
                    
                    # Focus on the frequency range of interest for dolphins (5-20 kHz)
                    plt.ylim(5, 20)
                    
                    # Save the plot
                    output_path = os.path.join(self.output_dir, f'fp_{os.path.splitext(filename)[0]}.png')
                    plt.savefig(output_path)
                    plt.close()
            else:
                # Create an empty plot with a message
                plt.figure(figsize=(12, 8))
                plt.text(0.5, 0.5, f"Audio file for index {file_index} not found", 
                         horizontalalignment='center', verticalalignment='center',
                         transform=plt.gca().transAxes, fontsize=14)
                plt.title(f'False Positive (Index: {file_index})')
                
                # Save the plot
                output_path = os.path.join(self.output_dir, f'fp_not_found_{file_index}.png')
                plt.savefig(output_path)
                plt.close()
        
        # Visualize false negatives (whistle classified as noise)
        print(f"Visualizing {len(fn_indices)} false negatives...")
        for i, idx in enumerate(tqdm(fn_indices, desc="Processing false negatives")):
            file_index = self.indices[idx]
            probability = self.probabilities[idx]
            
            # Try to find the audio file
            filepath, filename = self.find_audio_file(idx, file_index, all_audio_files)
            
            if filepath:
                # Read audio file
                audio, sample_rate = self.read_wav(filepath)
                
                if audio is not None and sample_rate is not None:
                    # Generate spectrogram
                    Sxx, freqs, times = self.get_spectrogram(audio, sample_rate)
                    
                    # Plot spectrogram
                    plt.figure(figsize=(12, 8))
                    plt.pcolormesh(times, freqs/1000, Sxx, shading='gouraud')
                    plt.colorbar(label='Power/Frequency (dB/Hz)')
                    plt.ylabel('Frequency (kHz)')
                    plt.xlabel('Time (s)')
                    plt.title(f'False Negative: {filename}\nWhistle classified as Noise (Prob: {probability:.3f})')
                    
                    # Focus on the frequency range of interest for dolphins (5-20 kHz)
                    plt.ylim(5, 20)
                    
                    # Save the plot
                    output_path = os.path.join(self.output_dir, f'fn_{os.path.splitext(filename)[0]}.png')
                    plt.savefig(output_path)
                    plt.close()
            else:
                # Create an empty plot with a message
                plt.figure(figsize=(12, 8))
                plt.text(0.5, 0.5, f"Audio file for index {file_index} not found", 
                         horizontalalignment='center', verticalalignment='center',
                         transform=plt.gca().transAxes, fontsize=14)
                plt.title(f'False Negative (Index: {file_index})')
                
                # Save the plot
                output_path = os.path.join(self.output_dir, f'fn_not_found_{file_index}.png')
                plt.savefig(output_path)
                plt.close()
        
        print(f"Saved all spectrograms to {self.output_dir}")
    
    def create_comparison_grid(self, random_seed=42):
        """
        Create a grid of spectrograms for comparison
        
        Args:
            random_seed: Random seed for reproducibility
        """
        # Set random seed for reproducibility
        np.random.seed(random_seed)
        
        # Get indices of false positives and false negatives
        fp_indices = np.where((self.predicted_labels == 1) & (self.true_labels == 0))[0]
        fn_indices = np.where((self.predicted_labels == 0) & (self.true_labels == 1))[0]
        
        # Shuffle indices
        np.random.shuffle(fp_indices)
        np.random.shuffle(fn_indices)
        
        # Use all examples for the grid
        num_examples = max(len(fp_indices), len(fn_indices))
        fp_indices = fp_indices[:num_examples]
        fn_indices = fn_indices[:num_examples]
        
        print(f"Creating comparison grid with all examples...")
        
        # Get list of all audio files
        all_audio_files = []
        for root, dirs, files in os.walk(self.audio_dir):
            for file in files:
                if file.endswith('.wav'):
                    all_audio_files.append((os.path.join(root, file), file))
        
        # Create figure with subplots
        fig, axes = plt.subplots(2, num_examples, figsize=(15, 8))
        
        # Plot false positives in the first row
        for i, idx in enumerate(fp_indices):
            file_index = self.indices[idx]
            
            # Try to find the audio file
            filepath, filename = self.find_audio_file(idx, file_index, all_audio_files)
            
            if filepath and i < num_examples:
                # Read audio file
                audio, sample_rate = self.read_wav(filepath)
                
                if audio is not None and sample_rate is not None:
                    # Generate spectrogram
                    Sxx, freqs, times = self.get_spectrogram(audio, sample_rate)
                    
                    # Plot spectrogram
                    im = axes[0, i].pcolormesh(times, freqs/1000, Sxx, shading='gouraud')
                    
                    # Focus on the frequency range of interest for dolphins (5-20 kHz)
                    axes[0, i].set_ylim(5, 20)
                    
                    # Set title
                    axes[0, i].set_title(f'FP: {os.path.splitext(filename)[0]}')
                    
                    # Only show y-label for the first column
                    if i == 0:
                        axes[0, i].set_ylabel('Frequency (kHz)')
                else:
                    axes[0, i].text(0.5, 0.5, "Error reading audio", 
                                   horizontalalignment='center', verticalalignment='center',
                                   transform=axes[0, i].transAxes, fontsize=10)
                    axes[0, i].set_title(f'FP: {file_index}')
            else:
                axes[0, i].text(0.5, 0.5, "File not found", 
                               horizontalalignment='center', verticalalignment='center',
                               transform=axes[0, i].transAxes, fontsize=10)
                axes[0, i].set_title(f'FP: {file_index}')
        
        # Plot false negatives in the second row
        for i, idx in enumerate(fn_indices):
            file_index = self.indices[idx]
            
            # Try to find the audio file
            filepath, filename = self.find_audio_file(idx, file_index, all_audio_files)
            
            if filepath and i < num_examples:
                # Read audio file
                audio, sample_rate = self.read_wav(filepath)
                
                if audio is not None and sample_rate is not None:
                    # Generate spectrogram
                    Sxx, freqs, times = self.get_spectrogram(audio, sample_rate)
                    
                    # Plot spectrogram
                    im = axes[1, i].pcolormesh(times, freqs/1000, Sxx, shading='gouraud')
                    
                    # Focus on the frequency range of interest for dolphins (5-20 kHz)
                    axes[1, i].set_ylim(5, 20)
                    
                    # Set title
                    axes[1, i].set_title(f'FN: {os.path.splitext(filename)[0]}')
                    
                    # Only show y-label for the first column
                    if i == 0:
                        axes[1, i].set_ylabel('Frequency (kHz)')
                    
                    # Only show x-label for the last row
                    axes[1, i].set_xlabel('Time (s)')
                else:
                    axes[1, i].text(0.5, 0.5, "Error reading audio", 
                                   horizontalalignment='center', verticalalignment='center',
                                   transform=axes[1, i].transAxes, fontsize=10)
                    axes[1, i].set_title(f'FN: {file_index}')
            else:
                axes[1, i].text(0.5, 0.5, "File not found", 
                               horizontalalignment='center', verticalalignment='center',
                               transform=axes[1, i].transAxes, fontsize=10)
                axes[1, i].set_title(f'FN: {file_index}')
        
        # Add colorbar
        cbar = fig.colorbar(im, ax=axes.ravel().tolist())
        cbar.set_label('Power/Frequency (dB/Hz)')
        
        plt.tight_layout()
        
        # Save figure
        output_path = os.path.join(self.output_dir, 'misclassified_comparison_grid.png')
        plt.savefig(output_path)
        plt.close()
        
        print(f"Saved comparison grid to {output_path}")

    def copy_misclassified_files(self, output_dir):
        """
        Copy misclassified whistle files (false negatives) to a specified directory
        
        Args:
            output_dir: Directory to copy files to
        """
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        # Get list of all audio files
        all_audio_files = []
        for root, dirs, files in os.walk(self.audio_dir):
            for file in files:
                if file.endswith('.wav'):
                    all_audio_files.append((os.path.join(root, file), file))
        
        print(f"Found {len(all_audio_files)} audio files in {self.audio_dir}")
        
        # Get indices for false negatives (whistles classified as noise)
        fn_indices = np.where((self.predicted_labels == 0) & (self.true_labels == 1))[0]
        print(f"Copying {len(fn_indices)} whistles misclassified as noise...")
        
        copied_files = 0
        for idx in fn_indices:
            file_index = self.indices[idx]
            
            # Try to find the audio file
            filepath, filename = self.find_audio_file(idx, file_index, all_audio_files)
            
            if filepath:
                # Use original filename
                output_path = os.path.join(output_dir, filename)
                
                # Copy the file
                try:
                    import shutil
                    shutil.copy2(filepath, output_path)
                    copied_files += 1
                    print(f"Copied {filename} to {output_path}")
                except Exception as e:
                    print(f"Error copying {filename}: {e}")
        
        print(f"Successfully copied {copied_files} misclassified whistle files to {output_dir}")

def main():
    """
    Main function
    """
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Visualize spectrograms of misclassified examples')
    parser.add_argument('--csv-file', type=str, default=None, help='Path to misclassified_examples.csv file')
    parser.add_argument('--audio-dir', type=str, default=None, help='Directory containing audio files')
    parser.add_argument('--output-dir', type=str, default=None, help='Directory to save spectrograms')
    parser.add_argument('--grid', action='store_true', help='Create a comparison grid of spectrograms')
    parser.add_argument('--copy-missed', type=str, help='Copy misclassified whistle files to specified directory')
    parser.add_argument('--random-seed', type=int, default=42, help='Random seed for reproducibility')
    parser.add_argument('--debug', action='store_true', help='Print debug information')
    args = parser.parse_args()
    
    # Set default paths if not provided
    base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    csv_file = args.csv_file or os.path.join(base_dir, 'dolphin_detector', 'output', 'misclassified_examples.csv')
    
    # For audio directory, try multiple possible locations
    if args.audio_dir:
        audio_dir = args.audio_dir
    else:
        # Try different possible locations
        possible_audio_dirs = [
            os.path.join(base_dir, 'hakaton', 'audio_train'),
            os.path.join(base_dir, 'audio_train'),
            os.path.join(base_dir, 'audio'),
            os.path.join(base_dir, 'data', 'audio'),
            os.path.join(base_dir, 'dolphin_detector', 'audio')
        ]
        
        audio_dir = None
        for dir_path in possible_audio_dirs:
            if os.path.exists(dir_path):
                audio_dir = dir_path
                break
        
        if audio_dir is None:
            print("Could not find audio directory. Please specify with --audio-dir")
            audio_dir = os.path.join(base_dir, 'hakaton', 'audio_train')  # Default as fallback
    
    if args.debug:
        print(f"Base directory: {base_dir}")
        print(f"CSV file: {csv_file}")
        print(f"Audio directory: {audio_dir}")
        print(f"Output directory: {args.output_dir or os.path.join(os.path.dirname(csv_file), 'spectrograms')}")
    
    # Create visualizer
    visualizer = MisclassifiedSpectrogramVisualizer(
        csv_file=csv_file,
        audio_dir=audio_dir,
        output_dir=args.output_dir
    )
    
    # Copy misclassified files if requested
    if args.copy_missed:
        visualizer.copy_misclassified_files(args.copy_missed)
    
    # Visualize spectrograms
    if not args.copy_missed or args.output_dir:
        visualizer.visualize_spectrograms(random_seed=args.random_seed)
        
        # Create comparison grid if requested
        if args.grid:
            visualizer.create_comparison_grid(random_seed=args.random_seed)

if __name__ == "__main__":
    main() 
